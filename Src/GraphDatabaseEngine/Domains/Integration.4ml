// ap R = WebGMEtoGraph(WebGMEModel)
// ex 0 R (ex TaskId ResultName)
// sv R r.4ml
transform WebGMEtoGraph (in:: WebGME)
returns (out:: GraphDatabase)
{
  out.Vertex(name, NIL) :- in.MetaNode(name).

  //out.sv is out.Vertex(sname, NIL),
  //out.dv is out.Vertex(dname, NIL),
  //out.msv is out.Vertex(NIL, PropertyList(Property("low", slow), PropertyList(Property("high", shigh), NIL))),
  //out.mdv is out.Vertex(NIL, PropertyList(Property("low", dlow), PropertyList(Property("high", dhigh), NIL))),

  out.Edge(name, out.Vertex(sname, NIL), out.Vertex(dname, NIL), NIL),
  out.Edge("ms", out.Vertex(sname, NIL), out.Vertex(NIL, PropertyList(Property("low", slow), PropertyList(Property("high", shigh), NIL))), NIL),
  out.Edge("md", out.Vertex(dname, NIL), out.Vertex(NIL, PropertyList(Property("low", dlow), PropertyList(Property("high", dhigh), NIL))), NIL)
  :-
  in.MetaEdge(name, src, dst, ms, md),
  src is in.MetaNode(sname), dst is in.MetaNode(dname),
  ms is in.Multiplicity(slow, shigh), md is in.Multiplicity(dlow, dhigh).
}


// ap R = FormulaRuleToGremlinQuery(tenMachineFormulaQueries)
// ex 0 R (ex TaskId ResultName)
// sv R r.4ml
transform FormulaRuleToGremlinQuery (in:: Formula)
returns (out:: Gremlin)
{
  //ContainsExpr ::= (in.Rule, in.Body, out.).

  // g.V().matchStep() for each rule.
  out.VariableDecl("g", out.OutVStep(NIL, out.MatchStep(rule_name, NIL))) :- in.Rule(rule_name,_,_).

  // Gremlin traversal models for model expressions.
  out.VariableDecl("g", out.OutVStep(NIL, out.MatchStep(rule_name, NIL))),
  out.MatchStepContainsInstruction(out.MatchStep(rule_name, NIL),
    out.AsStep(
      label.name, out.HasStep(
        "type", type.name, out.HasStep(
          "domain", "WebGME", out.InVStep(
            arg_x, out.AsStep(instanceLabel, NIL)))))
  )

  :-

  in.Rule(rule_name, head, body_header),
  in.BodySubterm(body_header, body),
  in.Body(expr, instance_index, body),
  expr = in.ModelExpr(type, labels),
  in.LabelsSubterm(labels, labels_x),
  labels_x = in.Labels(label, label_index, _),
  arg_x = strJoin("ARG_", toString(label_index)),
  instanceLabel = strJoin("instance_", strJoin(toString(instance_index), strJoin("_of_", label.type.name))).


  // Gremlin traversal models for binary expressions.
  out.MatchStepContainsInstruction(out.MatchStep(rule_name, NIL),
    out.AsStep(left.name, out.ValuesStep("value", out.AsStep(valueStr, NIL)))
  )
  :-
  in.Rule(rule_name, head, body_header),
  in.BodySubterm(body_header, body),
  in.Body(expr, instance_index, body),
  expr = in.BinaryExpr1(_,left,_), valueStr = strJoin(left.name, "_value").



  out.MatchStepContainsInstruction(out.MatchStep(rule_name, NIL),
    out.AsStep(left.name, out.ValuesStep("value", out.AsStep(valueStr, NIL)))
  )
  :-
  in.Rule(rule_name, head, body_header),
  in.BodySubterm(body_header, body),
  in.Body(expr, instance_index, body),
  expr is in.BinaryExpr2(_,left,_), valueStr = strJoin(left.name, "_value").



  out.MatchStepContainsInstruction(out.MatchStep(rule_name, NIL),
    out.AsStep(right.name, out.ValuesStep("value", out.AsStep(valueStr, NIL)))
  )
  :-
  in.Rule(rule_name, head, body_header),
  in.BodySubterm(body_header, body),
  in.Body(expr, instance_index, body),
  expr = in.BinaryExpr1(_,_,right), valueStr = strJoin(right.name, "_value").



  out.MatchStepContainsInstruction(out.MatchStep(rule_name, NIL),
    out.WhereStep(lvalueStr, out.Predicate(op, rvalueStr))
  )
  :-
  in.Rule(rule_name, head, body_header),
  in.BodySubterm(body_header, body),
  in.Body(expr, instance_index, body),
  expr = in.BinaryExpr1(op, left, right), lvalueStr = strJoin(left.name, "_value"), rvalueStr = strJoin(right.name, "_value").



  out.MatchStepContainsInstruction(out.MatchStep(rule_name, NIL),
    out.WhereStep(lvalueStr, out.Predicate(op, right))
  )
  :-
  in.Rule(rule_name, head, body_header),
  in.BodySubterm(body_header, body),
  in.Body(expr, instance_index, body),
  expr = in.BinaryExpr2(op, left, right), lvalueStr = strJoin(left.name, "_value").
}


// Parse a Formula program and create Formula models for Formula.
domain Formula
{
  Domain ::= new (String).
  FormulaBuiltInType ::= Integer + String + {NIL}.
  BaseType ::= new (name: String, argus: any Arguments + {NIL}).
  EnumList ::= new (cur: FormulaBuiltInType, nxt: any EnumList + {NIL}).
  EnumType ::= new (name: String, list: any EnumList).
  UnionList ::= new (cur: any BaseType + EnumType, nxt: any UnionList + {NIL}).
  UnionType ::= new (name: String, list: any UnionList).
  Type ::= BaseType + EnumType + UnionType.

  Argument ::= new (label: String + {NIL}, type: any Type).
  Arguments ::= new (cur: any Argument, index: Integer, nxt: any Arguments + {NIL}).

  // Related to Formula rule like TRUE :- C(a, b).
  Operator ::= {EQ, NEQ, LT, LTE, GT, GTE}.
  Label ::= new (name: String, type: any Type + {NIL}, fragments: any Labels + {NIL}).
  Labels ::= new (cur: any Label, index: Integer, nxt: any Labels + {NIL}).

  // Expressions
  Expr ::= BinaryExpr1 + BinaryExpr2 + BinaryExpr3 + ModelExpr + BoolExpr.

  // Separate Label and FormulaBuiltInType to avoid unsafe type in model transformation.
  BinaryExpr1 ::= new (op: Operator, left: Label, right: any Label).
  BinaryExpr2 ::= new (op: Operator, left: Label, right: any FormulaBuiltInType).
  BinaryExpr3 ::= new (op: Operator, left: any Count, right: any Label + Integer).
  ModelExpr ::= new (type: Type, labels: Labels).
  BoolExpr ::= new (label: Label).

  // Interpreted functions
  InterpretedFunc ::= Count + Min + Max.
  // Cannot have nested Count function inside Count function due to scope access.
  // Conforms: label must also occur in Body.
  Count ::= new (label: Label, body: any Body).
  Min ::= new (x: Integer, y: Integer).
  Max ::= new (x: Integer, y: Integer).

  Body ::= new (cur: any Expr, index: Integer, nxt: any Body + {NIL}).
  Head ::= new (cur: ModelExpr + BoolExpr, index: Integer, nxt: any ModelExpr + BoolExpr + {NIL}).
  Rule ::= new (name: String, head: Head, body: Body).

  // TODO: Find out why FORMULA cannot infer subterm() from nested ground terms like Labels(..., Labels()).
  // Many List interpreted functions are not implemented in FORMULA, so constructor Subterm() is defined for all list of different types
  LabelsSubterm ::= (Labels, Labels).
  LabelsSubterm(m, m) :- m is Labels(_,_,_).
  LabelsSubterm(m, n) :- m is Labels(_,_,n), n is Labels(_,_,_).
  LabelsSubterm(a, c) :- LabelsSubterm(a, b), LabelsSubterm(b, c).

  BodySubterm ::= (Body, Body).
  BodySubterm(m, m) :- m is Body(_,_,_).
  BodySubterm(m, n) :- m is Body(_,_,n), n is Body(_,_,_).
  BodySubterm(a, c) :- BodySubterm(a, b), BodySubterm(b, c).

  EnumListSubterm ::= (EnumList, EnumList).
  EnumListSubterm(m, m) :- m is EnumList(_,_).
  EnumListSubterm(m, n) :- m is EnumList(_,n), n is EnumList(_,_).
  EnumListSubterm(a, c) :- EnumListSubterm(a, b), EnumListSubterm(b, c).

  UnionListSubterm ::= (UnionList, UnionList).
  UnionListSubterm(m, m) :- m is UnionList(_,_).
  UnionListSubterm(m, n) :- m is UnionList(_,n), n is UnionList(_,_).
  UnionListSubterm(a, c) :- UnionListSubterm(a, b), UnionListSubterm(b, c).

  // Conforms ...
}


domain GraphDatabase
{
  PropType ::= String + Integer + Boolean.
  Vertex ::= new (name: any String + {NIL}, props: any PropertyList + {NIL}).
  Edge ::= new (label: String, src: Vertex, dst: Vertex, props: any PropertyList + {NIL}).
  Property ::= new (key: String, value: any PropType).

  PropertyList ::= new (Property, any PropertyList + {NIL}).
}

domain Gremlin extends GraphDatabase
{
  Strings ::= new (cur: String, index: Integer, nxt: any Strings + {NIL}).
  Predicate ::= new (op: Operator, value: any String + Integer + Boolean + {NIL}).

  // All Steps definition in Gremlin.
  VStep ::= new (num: any Integer + {NIL}, nxt: any Step + {NIL}).
  ByStep ::= new (label: String).
  HasStep ::= new (key: String, value: PropType, nxt: any Step + {NIL}).
  AsStep ::= new (labels: any String + Strings, nxt: any Step + {NIL}).
  SelectStep ::= new (labels: any String + Strings, nxt: any Step + {NIL}).
  OutVStep ::= new (edge: any String + {NIL}, nxt: any Step).
  InVStep ::= new (edge: String, nxt: any Step).
  OutEStep ::= new (edge: String, nxt: any Step).
  InEStep ::= new (edge: String, nxt: any Step).
  FilterStep ::= new (nxt: any Step).
  ValuesStep ::= new (key: String, nxt: any Step + {NIL}).
  IsStep ::= new (pred: any String + Integer + Predicate).
  WhereStep ::= new (label: String, pred: Predicate).


  // Match Step contains a list of Instructions and does not care about the order of sub-steps.
  MatchStep ::= new (name: String, nxt: any Step + {NIL}).
  MatchStepContainsInstruction ::= new (match: MatchStep, ins: Instruction).

  // Unify all types of traversal steps into Step.
  Step ::= VStep + HasStep + ByStep + AsStep + SelectStep + FilterStep + MatchStep + OutVStep + InVStep + OutEStep + InEStep + ValuesStep + IsStep + WhereStep.

  // Instruction contains a list of chains represented by their first element.
  Instruction ::= GremlinExpression + Step + VariableDecl.
  Instructions ::= new (cur: any Instruction, nxt: any Instructions + {NIL}).

  VariableDecl ::= new (label: String, nxt: any Step).
  Operator ::= {EQ, NEQ, LT, LTE, GT, GTE}.
  GremlinBinaryExpr ::= new (op: Operator, left: any String + Integer, right: any String + Integer).
  GremlinUnaryExpr ::= new (label: String).
  GremlinExpression ::= GremlinBinaryExpr + GremlinUnaryExpr.
  MethodCall ::= {ToList, IsEmpty}.
  TraversalElement ::= VariableDecl + Step + MethodCall.

  InstructionsSubterm ::= (Instructions, Instructions).
  InstructionsSubterm(m, m) :- m is Instructions(_,_).
  InstructionsSubterm(m, n) :- m is Instructions(_,n), n is Instructions(_,_).
  InstructionsSubterm(a, c) :- InstructionsSubterm(a, b), InstructionsSubterm(b, c).

  // Conforms ...
  // 1. Each Traversal element only has one succeesor.
  // 2. Set constraints for successor of traversal elements.
}


domain WebGME
{
  // Extend Anastasia's domain with properties.
  PropType ::= String + Integer + Boolean.
  Prop ::= new (key: String, value: any PropType).
  Props ::= new (Prop, any Props + {NIL}).

  MetaNode ::= new (name: String).
  MetaEdge ::= new (name: String, src: MetaNode, dst: MetaNode, ms: Multiplicity, md: Multiplicity).
  Multiplicity ::= new (low: Integer, high: Integer + {"*"}).

  Node ::= new (name: String, type: MetaNode).
  Edge ::= new (name: String, type: MetaEdge, src: Node, dst: Node).

  NodeInheritance ::= new (base: MetaNode, instance: MetaNode + Node).
  NodeInstanceOf ::= (MetaNode, MetaNode + Node).
  NodeInstanceOf(b,i) :- NodeInheritance(b,i).
  NodeInstanceOf(b,i) :- NodeInheritance(b,m), NodeInstanceOf(m,i).

  WrongMultiplicity :- Multiplicity(low,high), high != "*", low > high.

  not1 :- n is Node, no {m | m is MetaNode, NodeInstanceOf(m,n)}.
  not2 :- e is Edge, no {m | m is MetaEdge, m = e.type, NodeInstanceOf(m.src,e.src)}.
  not3 :- e is Edge, no {m | m is MetaEdge, m = e.type, NodeInstanceOf(m.dst,e.dst)}.
  not4a :- n is Node, m is MetaEdge, NodeInstanceOf(m.src,n), count({s|s is Node, e is Edge (_,m,n,s)}) < m.md.low.
  not4b :- n is Node, m is MetaEdge, NodeInstanceOf(m.src,n), m.md.high != "*", count({s|s is Node, e is Edge (_,m,n,s)}) > m.md.high.

  not5 :- m is MetaEdge, n is Node, NodeInstanceOf(m.src,n), m.md.low != 0, no{e | e is Edge(_,m,n,_)}.
  not6a :- n is Node, m is MetaEdge, NodeInstanceOf(m.dst,n), count({s|s is Node, e is Edge (_,m,s,n)}) < m.ms.low.
  not6b :- n is Node, m is MetaEdge, NodeInstanceOf(m.dst,n), m.ms.high != "*", count({s|s is Node, e is Edge (_,m,s,n)}) > m.ms.high.

  not7 :- m is MetaEdge, n is Node, NodeInstanceOf(m.dst,n), m.ms.low != 0, no{e | e is Edge(_,m,_,n)}.

}